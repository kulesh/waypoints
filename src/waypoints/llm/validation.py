"""Waypoint validation for LLM outputs.

Validates waypoints generated by LLM against JSON schema and semantic rules.
Used as a safety net for prompt-based JSON generation.
"""

import json
import re
from dataclasses import dataclass, field
from typing import Any

import jsonschema  # type: ignore[import-untyped]

# JSON Schema for waypoint array
WAYPOINT_SCHEMA: dict[str, Any] = {
    "type": "array",
    "items": {
        "type": "object",
        "required": ["id", "title", "objective", "acceptance_criteria"],
        "properties": {
            "id": {"type": "string", "pattern": "^WP-[0-9]+[a-z]?$"},
            "title": {"type": "string", "minLength": 3},
            "objective": {"type": "string", "minLength": 10},
            "acceptance_criteria": {
                "type": "array",
                "items": {"type": "string"},
                "minItems": 1,
            },
            "parent_id": {"type": ["string", "null"]},
            "dependencies": {
                "type": "array",
                "items": {"type": "string"},
                "default": [],
            },
        },
        "additionalProperties": False,
    },
}


class WaypointValidationError(Exception):
    """Validation failed with details."""

    def __init__(self, errors: list[str]) -> None:
        self.errors = errors
        super().__init__(f"Validation failed: {errors}")


@dataclass
class ValidationResult:
    """Result of waypoint validation."""

    valid: bool
    data: list[dict[str, Any]] | None = None
    errors: list[str] = field(default_factory=list)


def extract_json_array(response: str) -> list[dict[str, Any]]:
    """Extract JSON array from LLM response.

    Handles:
    - Plain JSON array
    - JSON wrapped in markdown code fences
    - JSON with surrounding text

    Args:
        response: Raw LLM response text.

    Returns:
        Parsed JSON array.

    Raises:
        ValueError: If no JSON array found.
        json.JSONDecodeError: If JSON is malformed.
    """
    # Strip markdown fences if present
    cleaned = re.sub(r"```json\s*", "", response)
    cleaned = re.sub(r"```\s*", "", cleaned)

    # Find array pattern
    match = re.search(r"\[[\s\S]*\]", cleaned)
    if not match:
        raise ValueError("No JSON array found in response")

    result: list[dict[str, Any]] = json.loads(match.group())
    return result


def validate_schema(data: list[dict[str, Any]]) -> list[str]:
    """Validate waypoints against JSON schema.

    Args:
        data: List of waypoint dictionaries.

    Returns:
        List of error messages (empty if valid).
    """
    errors: list[str] = []
    validator = jsonschema.Draft7Validator(WAYPOINT_SCHEMA)

    for error in validator.iter_errors(data):
        # Format path for readability
        path = error.json_path if error.json_path != "$" else "root"
        errors.append(f"{path}: {error.message}")

    return errors


def validate_semantics(
    data: list[dict[str, Any]], existing_ids: set[str] | None = None
) -> list[str]:
    """Validate semantic constraints on waypoints.

    Checks:
    - No duplicate IDs within batch
    - Parent IDs reference valid waypoints
    - Dependency IDs reference valid waypoints

    Args:
        data: List of waypoint dictionaries.
        existing_ids: Set of waypoint IDs that already exist (for sub-waypoints).

    Returns:
        List of error messages (empty if valid).
    """
    errors: list[str] = []
    ids_in_batch: set[str] = set()
    all_ids = (existing_ids or set()).copy()

    # First pass: collect all IDs in batch
    for wp in data:
        wp_id = wp.get("id", "")
        if wp_id:
            all_ids.add(wp_id)

    # Second pass: validate references
    for wp in data:
        wp_id = wp.get("id", "")

        # Duplicate check within batch
        if wp_id in ids_in_batch:
            errors.append(f"Duplicate ID: {wp_id}")
        ids_in_batch.add(wp_id)

        # Parent ref check
        parent_id = wp.get("parent_id")
        if parent_id and parent_id not in all_ids:
            errors.append(f"{wp_id}: parent_id '{parent_id}' not found")

        # Dependency ref check
        for dep_id in wp.get("dependencies", []):
            if dep_id not in all_ids:
                errors.append(f"{wp_id}: dependency '{dep_id}' not found")

    return errors


def validate_waypoints(
    response: str, existing_ids: set[str] | None = None
) -> ValidationResult:
    """Full validation pipeline for waypoint JSON.

    Args:
        response: Raw LLM response containing waypoint JSON.
        existing_ids: Set of existing waypoint IDs (for sub-waypoint generation).

    Returns:
        ValidationResult with valid flag, parsed data, and any errors.
    """
    # Extract JSON
    try:
        data = extract_json_array(response)
    except ValueError as e:
        return ValidationResult(valid=False, errors=[str(e)])
    except json.JSONDecodeError as e:
        return ValidationResult(valid=False, errors=[f"Invalid JSON: {e}"])

    # Schema validation
    schema_errors = validate_schema(data)
    if schema_errors:
        return ValidationResult(valid=False, errors=schema_errors)

    # Semantic validation
    semantic_errors = validate_semantics(data, existing_ids)
    if semantic_errors:
        return ValidationResult(valid=False, errors=semantic_errors)

    return ValidationResult(valid=True, data=data)
