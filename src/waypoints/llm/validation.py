"""Waypoint validation for LLM outputs.

Validates waypoints generated by LLM against JSON schema and semantic rules.
Used as a safety net for prompt-based JSON generation.
"""

import json
import re
from dataclasses import dataclass, field
from typing import Any

import jsonschema  # type: ignore[import-untyped]

# JSON Schema for a single waypoint (used when adding new waypoints)
SINGLE_WAYPOINT_SCHEMA: dict[str, Any] = {
    "type": "object",
    "required": ["id", "title", "objective", "acceptance_criteria"],
    "properties": {
        "id": {"type": "string", "pattern": "^WP-[0-9]+[a-z]?$"},
        "title": {"type": "string", "minLength": 3},
        "objective": {"type": "string", "minLength": 10},
        "acceptance_criteria": {
            "type": "array",
            "items": {"type": "string"},
            "minItems": 1,
        },
        "parent_id": {"type": ["string", "null"]},
        "dependencies": {
            "type": "array",
            "items": {"type": "string"},
            "default": [],
        },
        "insert_after": {"type": ["string", "null"]},
    },
    "additionalProperties": False,
}

# JSON Schema for waypoint array
WAYPOINT_SCHEMA: dict[str, Any] = {
    "type": "array",
    "items": {
        "type": "object",
        "required": ["id", "title", "objective", "acceptance_criteria"],
        "properties": {
            "id": {"type": "string", "pattern": "^WP-[0-9]+[a-z]?$"},
            "title": {"type": "string", "minLength": 3},
            "objective": {"type": "string", "minLength": 10},
            "acceptance_criteria": {
                "type": "array",
                "items": {"type": "string"},
                "minItems": 1,
            },
            "parent_id": {"type": ["string", "null"]},
            "dependencies": {
                "type": "array",
                "items": {"type": "string"},
                "default": [],
            },
        },
        "additionalProperties": False,
    },
}


class WaypointValidationError(Exception):
    """Validation failed with details."""

    def __init__(self, errors: list[str]) -> None:
        self.errors = errors
        super().__init__(f"Validation failed: {errors}")


@dataclass
class ValidationResult:
    """Result of waypoint validation."""

    valid: bool
    data: list[dict[str, Any]] | None = None
    errors: list[str] = field(default_factory=list)


def extract_json_array(response: str) -> list[dict[str, Any]]:
    """Extract JSON array from LLM response.

    Handles:
    - Plain JSON array
    - JSON wrapped in markdown code fences
    - JSON with surrounding text

    Args:
        response: Raw LLM response text.

    Returns:
        Parsed JSON array.

    Raises:
        ValueError: If no JSON array found.
        json.JSONDecodeError: If JSON is malformed.
    """
    # Strip markdown fences if present
    cleaned = re.sub(r"```json\s*", "", response)
    cleaned = re.sub(r"```\s*", "", cleaned)

    # Find array pattern
    match = re.search(r"\[[\s\S]*\]", cleaned)
    if not match:
        raise ValueError("No JSON array found in response")

    result: list[dict[str, Any]] = json.loads(match.group())
    return result


def validate_schema(data: list[dict[str, Any]]) -> list[str]:
    """Validate waypoints against JSON schema.

    Args:
        data: List of waypoint dictionaries.

    Returns:
        List of error messages (empty if valid).
    """
    errors: list[str] = []
    validator = jsonschema.Draft7Validator(WAYPOINT_SCHEMA)

    for error in validator.iter_errors(data):
        # Format path for readability
        path = error.json_path if error.json_path != "$" else "root"
        errors.append(f"{path}: {error.message}")

    return errors


def validate_semantics(
    data: list[dict[str, Any]], existing_ids: set[str] | None = None
) -> list[str]:
    """Validate semantic constraints on waypoints.

    Checks:
    - No duplicate IDs within batch
    - Parent IDs reference valid waypoints
    - Dependency IDs reference valid waypoints

    Args:
        data: List of waypoint dictionaries.
        existing_ids: Set of waypoint IDs that already exist (for sub-waypoints).

    Returns:
        List of error messages (empty if valid).
    """
    errors: list[str] = []
    ids_in_batch: set[str] = set()
    all_ids = (existing_ids or set()).copy()

    # First pass: collect all IDs in batch
    for wp in data:
        wp_id = wp.get("id", "")
        if wp_id:
            all_ids.add(wp_id)

    # Second pass: validate references
    for wp in data:
        wp_id = wp.get("id", "")

        # Duplicate check within batch
        if wp_id in ids_in_batch:
            errors.append(f"Duplicate ID: {wp_id}")
        ids_in_batch.add(wp_id)

        # Parent ref check
        parent_id = wp.get("parent_id")
        if parent_id and parent_id not in all_ids:
            errors.append(f"{wp_id}: parent_id '{parent_id}' not found")

        # Dependency ref check
        for dep_id in wp.get("dependencies", []):
            if dep_id not in all_ids:
                errors.append(f"{wp_id}: dependency '{dep_id}' not found")

    return errors


def validate_waypoints(
    response: str, existing_ids: set[str] | None = None
) -> ValidationResult:
    """Full validation pipeline for waypoint JSON.

    Args:
        response: Raw LLM response containing waypoint JSON.
        existing_ids: Set of existing waypoint IDs (for sub-waypoint generation).

    Returns:
        ValidationResult with valid flag, parsed data, and any errors.
    """
    # Extract JSON
    try:
        data = extract_json_array(response)
    except ValueError as e:
        return ValidationResult(valid=False, errors=[str(e)])
    except json.JSONDecodeError as e:
        return ValidationResult(valid=False, errors=[f"Invalid JSON: {e}"])

    # Schema validation
    schema_errors = validate_schema(data)
    if schema_errors:
        return ValidationResult(valid=False, errors=schema_errors)

    # Semantic validation
    semantic_errors = validate_semantics(data, existing_ids)
    if semantic_errors:
        return ValidationResult(valid=False, errors=semantic_errors)

    return ValidationResult(valid=True, data=data)


def extract_json_object(response: str) -> dict[str, Any]:
    """Extract JSON object from LLM response.

    Handles:
    - Plain JSON object
    - JSON wrapped in markdown code fences
    - JSON with surrounding text

    Args:
        response: Raw LLM response text.

    Returns:
        Parsed JSON object.

    Raises:
        ValueError: If no JSON object found.
        json.JSONDecodeError: If JSON is malformed.
    """
    # Strip markdown fences if present
    cleaned = re.sub(r"```json\s*", "", response)
    cleaned = re.sub(r"```\s*", "", cleaned)

    # Find object pattern (match outermost braces)
    match = re.search(r"\{[\s\S]*\}", cleaned)
    if not match:
        raise ValueError("No JSON object found in response")

    result: dict[str, Any] = json.loads(match.group())
    return result


@dataclass
class SingleWaypointResult:
    """Result of single waypoint validation."""

    valid: bool
    data: dict[str, Any] | None = None
    insert_after: str | None = None
    errors: list[str] = field(default_factory=list)


def validate_single_waypoint(
    response: str, existing_ids: set[str]
) -> SingleWaypointResult:
    """Validate a single waypoint from LLM response.

    Args:
        response: Raw LLM response containing waypoint JSON object.
        existing_ids: Set of existing waypoint IDs.

    Returns:
        SingleWaypointResult with valid flag, parsed data, insert position, and errors.
    """
    # Extract JSON object
    try:
        data = extract_json_object(response)
    except ValueError as e:
        return SingleWaypointResult(valid=False, errors=[str(e)])
    except json.JSONDecodeError as e:
        return SingleWaypointResult(valid=False, errors=[f"Invalid JSON: {e}"])

    # Schema validation
    errors: list[str] = []
    validator = jsonschema.Draft7Validator(SINGLE_WAYPOINT_SCHEMA)
    for error in validator.iter_errors(data):
        path = error.json_path if error.json_path != "$" else "root"
        errors.append(f"{path}: {error.message}")

    if errors:
        return SingleWaypointResult(valid=False, errors=errors)

    # Semantic validation
    wp_id = data.get("id", "")

    # Check ID not already used
    if wp_id in existing_ids:
        errors.append(f"ID '{wp_id}' already exists")

    # Check dependencies reference existing waypoints
    for dep_id in data.get("dependencies", []):
        if dep_id not in existing_ids:
            errors.append(f"Dependency '{dep_id}' not found")

    # Check insert_after references existing waypoint
    insert_after = data.get("insert_after")
    if insert_after and insert_after not in existing_ids:
        errors.append(f"insert_after '{insert_after}' not found")

    if errors:
        return SingleWaypointResult(valid=False, errors=errors)

    return SingleWaypointResult(valid=True, data=data, insert_after=insert_after)


# JSON Schema for reprioritization response
REPRIORITIZE_SCHEMA: dict[str, Any] = {
    "type": "object",
    "required": ["rationale", "order"],
    "properties": {
        "rationale": {"type": "string", "minLength": 10},
        "order": {
            "type": "array",
            "items": {"type": "string"},
            "minItems": 1,
        },
        "changes": {
            "type": "array",
            "items": {
                "type": "object",
                "properties": {
                    "id": {"type": "string"},
                    "reason": {"type": "string"},
                },
            },
        },
    },
    "additionalProperties": False,
}


@dataclass
class ReprioritizeResult:
    """Result of reprioritization validation."""

    valid: bool
    new_order: list[str] = field(default_factory=list)
    rationale: str = ""
    changes: list[dict[str, str]] = field(default_factory=list)
    errors: list[str] = field(default_factory=list)


def validate_reprioritization(
    response: str, root_waypoint_ids: set[str]
) -> ReprioritizeResult:
    """Validate reprioritization response from LLM.

    Args:
        response: Raw LLM response containing reprioritization JSON.
        root_waypoint_ids: Set of root waypoint IDs that must all be present.

    Returns:
        ReprioritizeResult with valid flag, new order, rationale, and errors.
    """
    # Extract JSON object
    try:
        data = extract_json_object(response)
    except ValueError as e:
        return ReprioritizeResult(valid=False, errors=[str(e)])
    except json.JSONDecodeError as e:
        return ReprioritizeResult(valid=False, errors=[f"Invalid JSON: {e}"])

    # Schema validation
    errors: list[str] = []
    validator = jsonschema.Draft7Validator(REPRIORITIZE_SCHEMA)
    for error in validator.iter_errors(data):
        path = error.json_path if error.json_path != "$" else "root"
        errors.append(f"{path}: {error.message}")

    if errors:
        return ReprioritizeResult(valid=False, errors=errors)

    # Validate all root waypoint IDs are present (no more, no less)
    order_ids = set(data.get("order", []))

    if order_ids != root_waypoint_ids:
        missing = root_waypoint_ids - order_ids
        extra = order_ids - root_waypoint_ids
        if missing:
            errors.append(f"Missing waypoints: {sorted(missing)}")
        if extra:
            errors.append(f"Unknown waypoints: {sorted(extra)}")
        return ReprioritizeResult(valid=False, errors=errors)

    return ReprioritizeResult(
        valid=True,
        new_order=data["order"],
        rationale=data.get("rationale", ""),
        changes=data.get("changes", []),
    )
